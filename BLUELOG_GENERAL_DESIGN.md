# Bluelog 全般設計ドキュメント

このドキュメントは、Bluelogアプリケーションの全体的な設計思想、主要機能、技術スタック、および運用に関する基本的な方針をまとめたものです。

## 1. プロジェクト概要と目的

Bluelogは、Blueskyの特定のユーザーの投稿や「いいね」を収集し、Twilogのように時系列で閲覧できるサービスを提供することを目的としています。ユーザーは自身のBlueskyアカウントをBluelogに連携することで、過去の活動履歴を容易に追跡・管理し、より深く理解することが可能になります。

## 2. 主要技術スタック

Bluelogは、Laravelフレームワークを基盤とし、Bluesky API連携ライブラリを活用して構築されています。詳細な技術スタックについては、プロジェクトルートの `GEMINI.md` を参照してください。

### 2.1. 開発環境の起動

Bluelogの開発環境を起動する際は、**必ず `npm run dev` コマンドを使用してください。**

このコマンドは、Laravel開発サーバー (`php artisan serve`)、フロントエンドのアセットをビルド・提供するVite、そしてバックグラウンドジョブを処理するキューワーカー (`php artisan queue:listen`) を同時に起動します。

`php artisan serve` 単独ではWebサーバーのみが起動し、キューワーカーは起動しません。そのため、`dispatch()` などでキューに投入されたジョブ（例: Blueskyからのデータ取得処理）が実行されず、アプリケーションの完全な動作を確認できません。キューワーカーの詳細な設定やタイムアウトについては、「5.4. キューワーカーの管理とタイムアウト設定」を参照してください。

## 3. Bluesky連携とデータ管理の概要

Bluelogの核となる機能は、Bluesky APIとのセキュアな連携と、取得したデータの効率的な管理によって実現されます。

### 3.1. 認証とトークン管理

Bluelogは、ユーザーのBlueskyアカウントへのアクセスを許可するため、アクセストークンとリフレッシュトークンを使用します。

*   **リフレッシュトークンの保管:** ユーザーがBluelogにログインした際、取得したリフレッシュトークンはデータベースに**暗号化して**保存されます。これにより、ユーザーがログアウトした後も、バックグラウンドでのデータ同期を継続できます。
*   **アクセストークンの保管:** アクセストークンは、ユーザーのWebセッション中にサーバーサイドのセッションに保存されます。これは、トークンがクライアントサイドに露出するリスクを防ぎ、セキュリティを強化するためです。
*   **トークンの自動更新:** アクセストークンが期限切れになった場合、保存されているリフレッシュトークンを使用して新しいアクセストークンを自動的に取得し、セッションを継続します。この処理は、ユーザーのログインセッション中およびバックグラウンドでのデータ取得処理の両方で行われます。
*   **セキュリティ方針:** 認証情報をURLパラメータとして渡すなど、セキュリティ上の脆弱性となる方法は一切採用しません。

### 3.2. データ取得と永続化

Bluelogは、ユーザーのBlueskyデータを定期的に取得し、データベースに永続化することで、高速なデータアクセスとBluesky APIのレートリミット遵守を実現します。

*   **データ取得のトリガー:** ユーザーログイン時、または定期的に実行されるバックグラウンドプロセスによって、Bluesky APIから最新のデータが取得されます。
*   **取得対象データ:** ユーザーのBlueskyプロフィール情報、投稿、いいねが主な取得対象です。投稿に付随するメディアやハッシュタグも抽出・保存されます。
*   **データモデル:** 取得されたデータは、ユーザー情報、投稿情報、いいね情報、メディア情報、ハッシュタグ情報、日別統計情報といった形でデータベースに保存されます。これにより、Bluesky上の活動履歴が構造化された形で保持されます。
*   **全体設定および招待コード:** グローバルなアプリ設定を保持する `settings` テーブル、招待コード管理用の `invitation_codes` と `invitation_code_usages` テーブルを新設しました。`App\Services\SettingService` を通じて設定値を取得・更新し、招待コードの発行や使用履歴を追跡します。
*   **統計情報の集計:** 日ごとの投稿数、いいね数、リプライ数、リポスト数などの統計情報が自動的に集計され、更新されます。

*   **データ取得の効率化**: 従来の全件取得方式から、Bluesky APIのContent ID (CID) を利用した差分同期方式に移行しました。これにより、前回同期した最新のCIDを基準に、それ以降の新しいデータのみを取得することで、APIリクエスト回数と処理負荷を大幅に削減し、スケーラビリティを向上させます。
*   **データ整合性の強化**: データアグリゲーションプロセスにおけるハッシュタグなどの関連データの登録において、冪等な操作を導入しました。これにより、重複挿入によるデータベースの制約違反を回避し、データ整合性を保証します.

### 3.3. 提供機能とデータ表示

Bluelogは、永続化されたBlueskyデータに基づき、以下の機能を提供します。

*   **ユーザープロフィール表示:** ユーザーの基本情報、統計情報、投稿一覧を表示します。投稿は検索、日付/月別アーカイブ、ソートが可能です。
*   **いいね履歴表示:** ユーザーが行った「いいね」の一覧を表示し、元の投稿コンテンツへのリンクを提供します。
*   **リプライランキング:** ユーザーがリプライした相手のランキングを表示します。
*   **ハッシュタグランキング:** ユーザーが使用したハッシュタグのランキングを表示します。
*   **活動統計グラフ:** ユーザーのBluesky活動の日ごとの統計をグラフで視覚化します。
*   **ユーザー設定:** プロフィール公開設定の変更、投稿データのエクスポート、アカウント削除機能を提供します。

*   **リアルタイムカウントの表示**: プロフィールヘッダーに表示される投稿数や「いいね」数などの統計情報は、関連する実データからリアルタイムにカウントされるようになり、常に最新の正確な情報を提供します.

## 4. 運用方針

### 4.1. 利用者設定モード

Bluelogでは、インスタンスの運用形態を柔軟に切り替えられるよう、次の2種類の登録モードを用意しています。設定値は `settings` テーブルに保存され、設定画面から変更できます。

*   **`single_user_only`**: 最初にログインしたユーザーのみが利用可能になるモードです。初回ログインユーザーのDIDが `allowed_single_user_did` として保存され、それ以外のユーザーはログインを拒否されます。
*   **`invitation_required`**: 招待コードを入力したユーザーのみが登録できます。招待コードは管理者が発行し、使用履歴は `invitation_code_usages` テーブルに記録されます。新規登録ユーザーには早期採用者フラグが付与されます。

### 4.2. クローリング拒否設定

クローラーによるページ取得を制御するため、`deny_all_crawlers` 設定を用意しました。設定画面で「全てを拒否する」を選択すると、 `/robots.txt` で `Disallow: /` を返すようになり、検索エンジンによるインデックスを防ぎます。

## 5. 今後の開発方針

*   **リポスト取得:** リポストの取得が行えていないため、実装する。
*   **テストの拡充:** 現在テストカバレッジが低い状態です。Bluesky連携部分のモック化を含めたテストを追加し、品質保証を強化します。

* **フロントエンドの改善:** よりインタラクティブでリッチなユーザーインターフェースを提供するため、モダンなJavaScriptフレームワークの導入を検討します。
*   **エラーハンドリングの強化:** Bluesky APIリクエストの失敗やデータ処理中のエラーなど、あらゆるエラーシナリオに対する堅牢なハンドリングメカニズムを実装します。
    
    *   **今後の課題:** さらなる堅牢性向上のため、回復処理（リトライなど）や、より詳細なエラー分類に基づくハンドリングの導入を検討します。
*   **パフォーマンス最適化:** 大規模なデータ量やユーザー数に対応するため、データベースクエリの最適化、キャッシュ戦略の導入、非同期処理の活用などにより、アプリケーション全体のパフォーマンス向上を図ります。
*   **スケーラビリティの向上:** ユーザー数の増加に対応できるよう、水平スケーリングを考慮したアーキテクチャ設計や、クラウドサービスの活用を検討します。

### 5.4. キューワーカーの管理とタイムアウト設定

Bluelogでは、Blueskyからのデータ取得など時間のかかる処理を非同期で実行するためにキューワーカーを利用します。キューワーカーの安定稼働と適切なタイムアウト設定は、アプリケーションの信頼性にとって重要です。

*   **キューワーカーの役割:**
    *   `dispatch()` 関数や `Artisan::call()` を用いてキューに投入されたジョブ（例: `status:aggregate` コマンド）をバックグラウンドで処理します。
    *   Webリクエストの処理とは独立して動作するため、ユーザー体験を損なうことなく重い処理を実行できます。

*   **開発環境での起動とタイムアウト設定:**
    *   **重要:** 開発環境では、Laravel開発サーバー、Vite、キューワーカーなどをまとめて起動するため、`php artisan serve` の単独実行ではなく、必ず `npm run dev` コマンドを使用してください。
    *   `npm run dev` コマンドを実行することで、Laravel開発サーバー、Vite、そしてキューワーカー (`php artisan queue:listen`) が同時に起動します。
    *   キューワーカーのタイムアウトは、`composer.json` の `scripts.dev` 内で `php artisan queue:listen` コマンドに `--timeout` オプションを指定することで設定されます。
    *   例: `"php artisan queue:listen --tries=1 --timeout=300"` (300秒 = 5分)
    *   この設定により、開発中に長時間かかるジョブが途中で強制終了されることを防ぎます。

*   **本番環境での起動とタイムアウト設定:**
    *   本番環境では、キューワーカーを常時稼働させるためにSupervisorなどのプロセス管理ツールを使用することが推奨されます。
    *   Supervisorの設定ファイル内で、`php artisan queue:work` または `php artisan queue:listen` コマンドに `--timeout` オプションを指定してタイムアウトを設定します。
    *   **例 (Supervisor設定):**
        ```ini
        [program:bluelog-worker]
        process_name=%(program_name)s_%(process_num)02d
        command=php /path/to/bluelog/artisan queue:work --timeout=300 --tries=3 --sleep=3
        autostart=true
        autorestart=true
        user=www-data ; または適切なユーザー名
        numprocs=1   ; 必要に応じてワーカー数を増やす
        redirect_stderr=true
        stdout_logfile=/path/to/bluelog/storage/logs/worker.log
        stopwaitsecs=300 ; ジョブが終了するまで待つ最大時間 (timeoutと同じかそれ以上が望ましい)
        ```
    *   **ジョブクラスごとのタイムアウト:** 特定のジョブのみ実行時間が長い場合は、そのジョブクラス内で `$timeout` プロパティを設定することも可能です。この設定はコマンドラインオプションよりも優先されます。
        ```php
        class MyLongRunningJob implements ShouldQueue
        {
            public $timeout = 600; // このジョブは600秒まで実行可能
            // ...
        }
        ```
    *   **`retry_after` と `timeout` の違い:**
        *   `--timeout` オプションやジョブクラスの `$timeout` プロパティは、ワーカーがジョブを強制終了するまでの時間です。
        *   `config/queue.php` に設定される `retry_after` は、ジョブが「失敗した」と見なされ、別のワーカーによって再試行されるまでの時間です。通常、`--timeout` や `$timeout` の値を `retry_after` よりも大きく設定することで、ジョブが完了する前に再試行されるのを防ぎます。

## 6. コードルール

プロジェクトのコードルールについては、プロジェクトルートの `GEMINI.md` を参照してください。

## 7. データベース抽象化と互換性

Bluelogでは、異なるデータベースドライバー（開発環境: SQLite, 本番環境: MariaDB）間での互換性を保ちつつ、データベース固有の関数を利用するために、`App\Models\Traits\HasDatabaseSpecificQueries` トレイトを導入しています。

### 7.1. `HasDatabaseSpecificQueries` トレイトの役割

このトレイトは、`posted_at` カラムから曜日や時間を抽出する際に、各データベースシステムに最適なSQL関数を動的に生成する役割を担います。これにより、アプリケーションコードが特定のデータベースに依存することなく、共通のインターフェースでデータ集計を行うことが可能になります。

*   **`getDayOfWeekSql()`:** データベースドライバーに応じて、投稿日時から曜日（0: 日曜日, ..., 6: 土曜日）を抽出するSQL式を返します。
*   **`getHourSql()`:** データベースドライバーに応じて、投稿日時から時間（0-23）を抽出するSQL式を返します。

### 7.2. 利用例 (`App\Models\Post` モデル)

`App\Models\Post` モデルでは、このトレイトを `use` することで、以下のスコープメソッドが利用可能になります。

*   **`scopePostsCountByDayOfWeek(Builder $query, string $did)`:** 特定のユーザーの投稿を対象に、曜日ごとの投稿数を集計します。内部で `getDayOfWeekSql()` を利用し、データベースに応じた適切なSQLを生成します。
*   **`scopePostsCountByHour(Builder $query, string $did)`:** 特定のユーザーの投稿を対象に、時間帯ごとの投稿数を集計します。内部で `getHourSql()` を利用し、データベースに応じた適切なSQLを生成します。

このアプローチにより、データベースの変更があった場合でも、アプリケーションのビジネスロジック層に大きな変更を加えることなく対応できる柔軟性が確保されています。
