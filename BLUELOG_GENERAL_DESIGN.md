# Bluelog 全般設計ドキュメント

このドキュメントは、Bluelogアプリケーションの全体的な設計思想、主要機能、技術スタック、および運用に関する基本的な方針をまとめたものです。

## 1. プロジェクト概要と目的

Bluelogは、Blueskyの特定のユーザーの投稿や「いいね」を収集し、Twilogのように時系列で閲覧できるサービスを提供することを目的としています。ユーザーは自身のBlueskyアカウントをBluelogに連携することで、過去の活動履歴を容易に追跡・管理し、より深く理解することが可能になります。

## 2. 主要技術スタック

Bluelogは、Laravelフレームワークを基盤とし、Bluesky API連携ライブラリを活用して構築されています。詳細な技術スタックについては、プロジェクトルートの `GEMINI.md` を参照してください。

### 2.1. 開発環境の起動

Bluelogの開発環境を起動する際は、**必ず `npm run dev` コマンドを使用してください。**

このコマンドは、Laravel開発サーバー (`php artisan serve`)、フロントエンドのアセットをビルド・提供するVite、そしてバックグラウンドジョブを処理するキューワーカー (`php artisan queue:listen`) を同時に起動します。

`php artisan serve` 単独ではWebサーバーのみが起動し、キューワーカーは起動しません。そのため、`dispatch()` などでキューに投入されたジョブ（例: Blueskyからのデータ取得処理）が実行されず、アプリケーションの完全な動作を確認できません。キューワーカーの詳細な設定やタイムアウトについては、「5.4. キューワーカーの管理とタイムアウト設定」を参照してください。

## 3. Bluesky連携とデータ管理の概要

Bluelogの核となる機能は、Bluesky APIとのセキュアな連携と、取得したデータの効率的な管理によって実現されます。

### 3.1. 認証とトークン管理

Bluelogは、ユーザーのBlueskyアカウントへのアクセスを許可するため、アクセストークンとリフレッシュトークンを使用します。

*   **リフレッシュトークンの保管:** ユーザーがBluelogにログインした際、取得したリフレッシュトークンはデータベースに**暗号化して**保存されます。これにより、ユーザーがログアウトした後も、バックグラウンドでのデータ同期を継続できます。
*   **アクセストークンの保管:** アクセストークンは、ユーザーのWebセッション中にサーバーサイドのセッションに保存されます。これは、トークンがクライアントサイドに露出するリスクを防ぎ、セキュリティを強化するためです。
*   **トークンの自動更新:** アクセストークンが期限切れになった場合、保存されているリフレッシュトークンを使用して新しいアクセストークンを自動的に取得し、セッションを継続します。この処理は、ユーザーのログインセッション中およびバックグラウンドでのデータ取得処理の両方で行われます。
*   **セキュリティ方針:** 認証情報をURLパラメータとして渡すなど、セキュリティ上の脆弱性となる方法は一切採用しません。

### 3.2. データ取得と永続化

Bluelogは、ユーザーのBlueskyデータを定期的に取得し、データベースに永続化することで、高速なデータアクセスとBluesky APIのレートリミット遵守を実現します。

*   **データ取得のトリガー:** ユーザーログイン時、または定期的に実行されるバックグラウンドプロセスによって、Bluesky APIから最新のデータが取得されます。
*   **取得対象データ:** ユーザーのBlueskyプロフィール情報、投稿、いいねが主な取得対象です。投稿に付随するメディアやハッシュタグも抽出・保存されます。
*   **データモデル:** 取得されたデータは、ユーザー情報、投稿情報、いいね情報、メディア情報、ハッシュタグ情報、日別統計情報といった形でデータベースに保存されます。これにより、Bluesky上の活動履歴が構造化された形で保持されます。
*   **統計情報の集計:** 日ごとの投稿数、いいね数、リプライ数、リポスト数などの統計情報が自動的に集計され、更新されます。

### 3.3. 提供機能とデータ表示

Bluelogは、永続化されたBlueskyデータに基づき、以下の機能を提供します。

*   **ユーザープロフィール表示:** ユーザーの基本情報、統計情報、投稿一覧を表示します。投稿は検索、日付/月別アーカイブ、ソートが可能です。
*   **いいね履歴表示:** ユーザーが行った「いいね」の一覧を表示し、元の投稿コンテンツへのリンクを提供します。
*   **リプライランキング:** ユーザーがリプライした相手のランキングを表示します。
*   **ハッシュタグランキング:** ユーザーが使用したハッシュタグのランキングを表示します。
*   **活動統計グラフ:** ユーザーのBluesky活動の日ごとの統計をグラフで視覚化します。
*   **ユーザー設定:** プロフィール公開設定の変更、投稿データのエクスポート、アカウント削除機能を提供します。

## 4. 運用方針

### 4.1. 招待コード制の導入（サービス稼働初期）

Bluelogのサービス稼働初期段階においては、システムの安定性と品質を確保するため、ユーザー登録を招待コード制とします。これは、段階的なユーザー増加を管理し、予期せぬ問題への対応を容易にするための戦略です。

**現状と今後の課題:**

現在のBluelogの実装では、招待コード制は導入されていません。ユーザーはBlueskyアカウントで直接ログインできます。招待コード制は、サービス稼働初期のユーザー管理と負荷分散のための重要な機能であり、今後の実装課題として検討が必要です。

**今後の対応:**

*   招待コードの生成、管理、検証ロジックを実装する。
*   ユーザー登録フローに招待コードの入力を組み込む。
*   管理者向けの招待コード発行機能を追加する。

*   **目的:**
    *   **動作チェック:** 少数の招待ユーザーを通じて、新規ユーザー登録からデータ同期、閲覧までのアプリケーションフローが本番環境で想定通りに動作するかを確認します。
    *   **負荷チェック:** 段階的にユーザー数を増やすことで、システムがどの程度の同時接続数やデータ量に耐えられるかを検証し、ボトルネックを特定します。
    *   **段階的なユーザー増加:** サービス開始直後の予期せぬ問題発生時の影響範囲を限定し、迅速な修正と対応を可能にします。
    *   **フィードバックの収集:** 初期ユーザーからのフィードバックを積極的に収集し、機能改善やUI/UXの向上に役立てます。
*   **導入フェーズ:** Bluelogの一般公開初期フェーズに限定して適用されます。このフェーズでは、招待コードを持たないユーザーは登録できません。
*   **運用方法:**
    *   **招待コードの発行:** 管理者のみが招待コードを発行できる機能を設けます。招待コードは、一意で推測が困難な文字列とします。
    *   **登録時の必須入力:** ユーザー登録フォームにおいて、招待コードの入力を必須項目とします。
    *   **一回限りの使用:** 発行された招待コードは、原則として一度のみ使用可能とし、再利用は不可とします。
    *   **招待コードの配布:** 招待コードは、信頼できるチャネルを通じて、限定されたユーザーに配布されます。
*   **解除条件:**
    *   システムの安定性（パフォーマンス、エラー発生率、リソース使用量など）が一定の基準を満たし、大規模なユーザーベースに対応可能と判断された段階で、招待コード制は解除される可能性があります。解除の判断は、運用チームによって行われます。
*   **セキュリティ上の考慮事項:**
    *   招待コードはデータベースにハッシュ化して保存するか、有効期限を設定するなど、セキュリティを考慮した管理を行います。
    *   招待コードの配布方法についても、情報漏洩のリスクを最小限に抑えるための対策を講じます。

## 5. 今後の開発方針

*   **テストの拡充:** 現在テストカバレッジが低い状態です。Bluesky連携部分のモック化を含めたテストを追加し、品質保証を強化します。
*   **フロントエンドの改善:** よりインタラクティブでリッチなユーザーインターフェースを提供するため、モダンなJavaScriptフレームワークの導入を検討します。
*   **エラーハンドリングの強化:** Bluesky APIリクエストの失敗やデータ処理中のエラーなど、あらゆるエラーシナリオに対する堅牢なハンドリングメカニズムを実装します。
    
    *   **今後の課題:** さらなる堅牢性向上のため、回復処理（リトライなど）や、より詳細なエラー分類に基づくハンドリングの導入を検討します。
*   **パフォーマンス最適化:** 大規模なデータ量やユーザー数に対応するため、データベースクエリの最適化、キャッシュ戦略の導入、非同期処理の活用などにより、アプリケーション全体のパフォーマンス向上を図ります。
*   **スケーラビリティの向上:** ユーザー数の増加に対応できるよう、水平スケーリングを考慮したアーキテクチャ設計や、クラウドサービスの活用を検討します。

### 5.4. キューワーカーの管理とタイムアウト設定

Bluelogでは、Blueskyからのデータ取得など時間のかかる処理を非同期で実行するためにキューワーカーを利用します。キューワーカーの安定稼働と適切なタイムアウト設定は、アプリケーションの信頼性にとって重要です。

*   **キューワーカーの役割:**
    *   `dispatch()` 関数や `Artisan::call()` を用いてキューに投入されたジョブ（例: `status:aggregate` コマンド）をバックグラウンドで処理します。
    *   Webリクエストの処理とは独立して動作するため、ユーザー体験を損なうことなく重い処理を実行できます。

*   **開発環境での起動とタイムアウト設定:**
    *   **重要:** 開発環境では、Laravel開発サーバー、Vite、キューワーカーなどをまとめて起動するため、`php artisan serve` の単独実行ではなく、必ず `npm run dev` コマンドを使用してください。
    *   `npm run dev` コマンドを実行することで、Laravel開発サーバー、Vite、そしてキューワーカー (`php artisan queue:listen`) が同時に起動します。
    *   キューワーカーのタイムアウトは、`composer.json` の `scripts.dev` 内で `php artisan queue:listen` コマンドに `--timeout` オプションを指定することで設定されます。
    *   例: `"php artisan queue:listen --tries=1 --timeout=300"` (300秒 = 5分)
    *   この設定により、開発中に長時間かかるジョブが途中で強制終了されることを防ぎます。

*   **本番環境での起動とタイムアウト設定:**
    *   本番環境では、キューワーカーを常時稼働させるためにSupervisorなどのプロセス管理ツールを使用することが推奨されます。
    *   Supervisorの設定ファイル内で、`php artisan queue:work` または `php artisan queue:listen` コマンドに `--timeout` オプションを指定してタイムアウトを設定します。
    *   **例 (Supervisor設定):**
        ```ini
        [program:bluelog-worker]
        process_name=%(program_name)s_%(process_num)02d
        command=php /path/to/bluelog/artisan queue:work --timeout=300 --tries=3 --sleep=3
        autostart=true
        autorestart=true
        user=www-data ; または適切なユーザー名
        numprocs=1   ; 必要に応じてワーカー数を増やす
        redirect_stderr=true
        stdout_logfile=/path/to/bluelog/storage/logs/worker.log
        stopwaitsecs=300 ; ジョブが終了するまで待つ最大時間 (timeoutと同じかそれ以上が望ましい)
        ```
    *   **ジョブクラスごとのタイムアウト:** 特定のジョブのみ実行時間が長い場合は、そのジョブクラス内で `$timeout` プロパティを設定することも可能です。この設定はコマンドラインオプションよりも優先されます。
        ```php
        class MyLongRunningJob implements ShouldQueue
        {
            public $timeout = 600; // このジョブは600秒まで実行可能
            // ...
        }
        ```
    *   **`retry_after` と `timeout` の違い:**
        *   `--timeout` オプションやジョブクラスの `$timeout` プロパティは、ワーカーがジョブを強制終了するまでの時間です。
        *   `config/queue.php` に設定される `retry_after` は、ジョブが「失敗した」と見なされ、別のワーカーによって再試行されるまでの時間です。通常、`--timeout` や `$timeout` の値を `retry_after` よりも大きく設定することで、ジョブが完了する前に再試行されるのを防ぎます。

## 6. コードルール

プロジェクトのコードルールについては、プロジェクトルートの `GEMINI.md` を参照してください。

## 7. データベース抽象化と互換性

Bluelogでは、異なるデータベースドライバー（開発環境: SQLite, 本番環境: MariaDB）間での互換性を保ちつつ、データベース固有の関数を利用するために、`App\Models\Traits\HasDatabaseSpecificQueries` トレイトを導入しています。

### 7.1. `HasDatabaseSpecificQueries` トレイトの役割

このトレイトは、`posted_at` カラムから曜日や時間を抽出する際に、各データベースシステムに最適なSQL関数を動的に生成する役割を担います。これにより、アプリケーションコードが特定のデータベースに依存することなく、共通のインターフェースでデータ集計を行うことが可能になります。

*   **`getDayOfWeekSql()`:** データベースドライバーに応じて、投稿日時から曜日（0: 日曜日, ..., 6: 土曜日）を抽出するSQL式を返します。
*   **`getHourSql()`:** データベースドライバーに応じて、投稿日時から時間（0-23）を抽出するSQL式を返します。

### 7.2. 利用例 (`App\Models\Post` モデル)

`App\Models\Post` モデルでは、このトレイトを `use` することで、以下のスコープメソッドが利用可能になります。

*   **`scopePostsCountByDayOfWeek(Builder $query, string $did)`:** 特定のユーザーの投稿を対象に、曜日ごとの投稿数を集計します。内部で `getDayOfWeekSql()` を利用し、データベースに応じた適切なSQLを生成します。
*   **`scopePostsCountByHour(Builder $query, string $did)`:** 特定のユーザーの投稿を対象に、時間帯ごとの投稿数を集計します。内部で `getHourSql()` を利用し、データベースに応じた適切なSQLを生成します。

このアプローチにより、データベースの変更があった場合でも、アプリケーションのビジネスロジック層に大きな変更を加えることなく対応できる柔軟性が確保されています。
